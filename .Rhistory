variable_input(functions = fun, variables, numbers)
seed <- as.integer(sample(1e+10, 1))
seed
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
as.integer(sample(1e+10, 1))
as.integer(sample(1e+10, 1))
as.integer(sample(1e+10, 1))
as.integer(sample(1e+10, 1))
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
sample(1e+10, 1)
seed <- sample(1e+10, 1)
# use parlapply version for windows
cl <- parallel::makeCluster(no_cores)
parallel::clusterSetRNGStream(cl, iseed = seed)
str(seed)
as.integer(sample(1e+10, 1))
as.integer(sample(1e+10, 1))
as.integer(sample(1e+10, 1))
as.integer(sample(1e+10, 1))
as.integer(sample(1e+10, 1))
# NULL seed
if(is.null(seed)) seed <- sample(1e+10, 1)
seed
as.integer(seed
# Calculate the number of cores if not specified
if (is.null(no_cores)) {
no_cores <- min(1, parallel::detectCores() - 2)
}
no_cores <- min(parallel::detectCores(), no_cores)
# parallel sampling
cat("Sampling varialbes and/or numerics", n_iter, "times with", no_cores, "cores:\n")
if(Sys.info()[["sysname"]] == "Windows"){
# use parlapply version for windows
cl <- parallel::makeCluster(no_cores)
parallel::clusterSetRNGStream(cl, iseed = seed)
parallel::clusterExport(cl, list(".var_sampler", ".simple_grammar_sampler",
"variables", "numbers", "create_grammar",
".grammar_sample", "n_iter"),
envir = environment())
output <- pbapply::pblapply(functions,
FUN = .var_sampler,
variables = variables,
numbers = numbers,
n_iter = n_iter,
cl = cl)
parallel::stopCluster(cl)
} else {
RNGkind("L'Ecuyer-CMRG")
set.seed(seed)
parallel::mc.reset.stream()
output <- unlist(pbmcapply::pbmclapply(X = functions,
FUN = .var_sampler,
variables = variables,
numbers = numbers,
n_iter = n_iter,
mc.cores = as.integer(no_cores)))
}
}
variable_input(functions = fun, variables, numbers)
# Functions for randomly putting in numeric values from given range
num_input <- function(fun){
while(length(grep("numeric", fun)) != 0){
fun <- sub("numeric", sample(numbers, 1), fun)
}
return(fun)
}
nums_input <- function(fun){
fun <- gsub(" ", "", fun)
funs <- replicate(10, num_input(fun))
funs <- gsub("+-", "-", funs, fixed = TRUE)
funs <- gsub("--", "+", funs, fixed = TRUE)
funs <- gsub("++", "+", funs, fixed = TRUE)
funs <- gsub("-+", "-", funs, fixed = TRUE)
return(funs)
}
num_df_input <- function(functions, numbers){
number_list <- lapply(functions, nums_input)
return(do.call(c, number_list))
}
# Create new function vector with 10 numeric inputs each
meh <- num_df_input(funs, numbers)
for(i in 51:80){
print(i)
Deriv::Simplify(meh[64])
}
Deriv::Simplify("sqrt(1+2)")
exp(-1/1)*(1/1-(log2(1.5*-1.5)))-(-0.2*-0.6)
.simplify_single_function(funs[64, 1], function_variables = "var")
dim(funs)
funs2 <- grammar_sampler(n = 100, grammar = grammar, max_depth = 10,
no_cores = 10, seed = 124, save = FALSE)
dim(funs2)
sum(funs == funs2) == nrow(funs)
funs2 <- funs
# 25s 1e+5 10 cores
#
simplify_functions(function_strings = test, function_variables = c("sp"),
no_cores = 1)
rand_grammar_sampler(gram = g, gram_table = gram_table, depth = 2)
# 3. Add range of terminals --------------------------------------------------------------
# bd = bulk density, ld = lower depth of horizon, ud = uppder depth of horizon,
# karstic = 0(FALSE)/1(TRUE)
# not used: land_cover, classunit, karstic
spatial_predictors <- c("bd", "bd_till", "sand", "clay", "slope", "aspect", "dem",
"ld", "ud", "lai_class")
# everything except atan2, max, min
#logical <- c('else', 'if', 'then', 'end', 'where', '<=', '<', '>=', '>', '==',
#             '.and.','.or.')
spatial_predictors <- c("aspect", "bd", "classunit", "clay", "karstic",
"lai_class", "land_cover", "sand", "slope", "ud")
as.integer(seed)
seed
class(seed)
seedL
trunc(seed)
str(trunc(seed))
as.integer(trunc(seed))
integer(trunc(seed))
as.integer(2)
as.integer(2)
seed <- sample(1e+10, 1)
seed <- sample.int(1e+10, 1)
str(seed)
seed <- sample.int(10000000000, 1)
# use parlapply version for windows
cl <- parallel::makeCluster(no_cores)
parallel::clusterSetRNGStream(cl, iseed = seed)
seed <- sample(10000000, 1)
parallel::clusterSetRNGStream(cl, iseed = seed)
# use parlapply version for windows
cl <- parallel::makeCluster(no_cores)
parallel::clusterSetRNGStream(cl, iseed = seed)
seed <- sample(100000000, 1)
parallel::clusterSetRNGStream(cl, iseed = seed)
seed <- sample(1000000000, 1)
seed <- 1000000000
as.integer(seed)
seed <- 10000000000
as.integer(seed)
seed <- 1e+9
as.integer(seed)
seed <- 1e+9 + 1
as.integer(seed)
variable_input <- function(functions, variables, numbers, n_iter = 100, no_cores = NULL, seed = NULL){
# NULL seed
if(is.null(seed)) seed <- sample(1e+9, 1)
# Calculate the number of cores if not specified
if (is.null(no_cores)) {
no_cores <- min(1, parallel::detectCores() - 2)
}
no_cores <- min(parallel::detectCores(), no_cores)
# parallel sampling
cat("Sampling varialbes and/or numerics", n_iter, "times with", no_cores, "cores:\n")
if(Sys.info()[["sysname"]] == "Windows"){
# use parlapply version for windows
cl <- parallel::makeCluster(no_cores)
parallel::clusterSetRNGStream(cl, iseed = seed)
parallel::clusterExport(cl, list(".var_sampler", ".simple_grammar_sampler",
"variables", "numbers", "create_grammar",
".grammar_sample", "n_iter"),
envir = environment())
output <- pbapply::pblapply(functions,
FUN = .var_sampler,
variables = variables,
numbers = numbers,
n_iter = n_iter,
cl = cl)
parallel::stopCluster(cl)
} else {
RNGkind("L'Ecuyer-CMRG")
set.seed(seed)
parallel::mc.reset.stream()
output <- unlist(pbmcapply::pbmclapply(X = functions,
FUN = .var_sampler,
variables = variables,
numbers = numbers,
n_iter = n_iter,
mc.cores = as.integer(no_cores)))
}
}
variable_input(functions = fun, variables, numbers)
fun
# 4. Sample variables and numerics -------------------------------------------------------
fun <- fundf[1:122, 1]
numbers <- seq(0.1, 3, 0.05)
variables <- c("bd", "bd_till", "sand", "clay", "slope", "aspect", "dem", "ld", "ud")
variable_input <- function(functions, variables, numbers, n_iter = 100, no_cores = NULL, seed = NULL){
# NULL seed
if(is.null(seed)) seed <- sample(1e+9, 1)
# Calculate the number of cores if not specified
if (is.null(no_cores)) {
no_cores <- min(1, parallel::detectCores() - 2)
}
no_cores <- min(parallel::detectCores(), no_cores)
# parallel sampling
cat("Sampling varialbes and/or numerics", n_iter, "times with", no_cores, "cores:\n")
if(Sys.info()[["sysname"]] == "Windows"){
# use parlapply version for windows
cl <- parallel::makeCluster(no_cores)
parallel::clusterSetRNGStream(cl, iseed = seed)
parallel::clusterExport(cl, list(".var_sampler", ".simple_grammar_sampler",
"variables", "numbers", "create_grammar",
".grammar_sample", "n_iter"),
envir = environment())
output <- pbapply::pblapply(functions,
FUN = .var_sampler,
variables = variables,
numbers = numbers,
n_iter = n_iter,
cl = cl)
parallel::stopCluster(cl)
} else {
RNGkind("L'Ecuyer-CMRG")
set.seed(seed)
parallel::mc.reset.stream()
output <- unlist(pbmcapply::pbmclapply(X = functions,
FUN = .var_sampler,
variables = variables,
numbers = numbers,
n_iter = n_iter,
mc.cores = as.integer(no_cores)))
}
}
variable_input(functions = fun, variables, numbers)
variable_input <- function(functions, variables, numbers, n_iter = 100, no_cores = NULL, seed = NULL){
if(is.data.frame(functions) & ncol(functions) == 1){
functions <- as.character(functions)
} else {
stop("functions must be either a character vector or a 1 column data frame with function strings.")
}
# NULL seed
if(is.null(seed)) seed <- sample(1e+9, 1)
# Calculate the number of cores if not specified
if (is.null(no_cores)) {
no_cores <- min(1, parallel::detectCores() - 2)
}
no_cores <- min(parallel::detectCores(), no_cores)
# parallel sampling
cat("Sampling varialbes and/or numerics", n_iter, "times with", no_cores, "cores:\n")
if(Sys.info()[["sysname"]] == "Windows"){
# use parlapply version for windows
cl <- parallel::makeCluster(no_cores)
parallel::clusterSetRNGStream(cl, iseed = seed)
parallel::clusterExport(cl, list(".var_sampler", ".simple_grammar_sampler",
"variables", "numbers", "create_grammar",
".grammar_sample", "n_iter"),
envir = environment())
output <- pbapply::pblapply(functions,
FUN = .var_sampler,
variables = variables,
numbers = numbers,
n_iter = n_iter,
cl = cl)
parallel::stopCluster(cl)
} else {
RNGkind("L'Ecuyer-CMRG")
set.seed(seed)
parallel::mc.reset.stream()
output <- unlist(pbmcapply::pbmclapply(X = functions,
FUN = .var_sampler,
variables = variables,
numbers = numbers,
n_iter = n_iter,
mc.cores = as.integer(no_cores)))
}
output <- unique(output)
return(output)
}
bla <- variable_input(functions = fun, variables, numbers)
# 4. Sample variables and numerics -------------------------------------------------------
fun <- fundf[1:122, 1]
numbers <- seq(0.1, 3, 0.05)
variables <- c("bd", "bd_till", "sand", "clay", "slope", "aspect", "dem", "ld", "ud")
variable_input <- function(functions, variables, numbers, n_iter = 100, no_cores = NULL, seed = NULL){
if(is.data.frame(functions) & ncol(functions) == 1){
functions <- as.character(functions)
} else {
stop("functions must be either a character vector or a 1 column data frame with function strings.")
}
# NULL seed
if(is.null(seed)) seed <- sample(1e+9, 1)
# Calculate the number of cores if not specified
if (is.null(no_cores)) {
no_cores <- min(1, parallel::detectCores() - 2)
}
no_cores <- min(parallel::detectCores(), no_cores)
# parallel sampling
cat("Sampling varialbes and/or numerics", n_iter, "times with", no_cores, "cores:\n")
if(Sys.info()[["sysname"]] == "Windows"){
# use parlapply version for windows
cl <- parallel::makeCluster(no_cores)
parallel::clusterSetRNGStream(cl, iseed = seed)
parallel::clusterExport(cl, list(".var_sampler", ".simple_grammar_sampler",
"variables", "numbers", "create_grammar",
".grammar_sample", "n_iter"),
envir = environment())
output <- pbapply::pblapply(functions,
FUN = .var_sampler,
variables = variables,
numbers = numbers,
n_iter = n_iter,
cl = cl)
parallel::stopCluster(cl)
} else {
RNGkind("L'Ecuyer-CMRG")
set.seed(seed)
parallel::mc.reset.stream()
output <- unlist(pbmcapply::pbmclapply(X = functions,
FUN = .var_sampler,
variables = variables,
numbers = numbers,
n_iter = n_iter,
mc.cores = as.integer(no_cores)))
}
output <- unique(output)
return(output)
}
bla <- variable_input(functions = fun, variables, numbers)
if(is.data.frame(functions)){
if(ncol(functions) == 1){
functions <- as.character(functions)
} else stop("functions must be either a character vector or a 1 column data frame with function strings.")
} else {
if(!is.character(functions)){
stop("functions must be either a character vector or a 1 column data frame with function strings.")
}
}
variable_input <- function(functions, variables, numbers, n_iter = 100, no_cores = NULL, seed = NULL){
if(is.data.frame(functions)){
if(ncol(functions) == 1){
functions <- as.character(functions)
} else stop("functions must be either a character vector or a 1 column data frame with function strings.")
} else {
if(!is.character(functions)){
stop("functions must be either a character vector or a 1 column data frame with function strings.")
}
}
# NULL seed
if(is.null(seed)) seed <- sample(1e+9, 1)
# Calculate the number of cores if not specified
if (is.null(no_cores)) {
no_cores <- min(1, parallel::detectCores() - 2)
}
no_cores <- min(parallel::detectCores(), no_cores)
# parallel sampling
cat("Sampling varialbes and/or numerics", n_iter, "times with", no_cores, "cores:\n")
if(Sys.info()[["sysname"]] == "Windows"){
# use parlapply version for windows
cl <- parallel::makeCluster(no_cores)
parallel::clusterSetRNGStream(cl, iseed = seed)
parallel::clusterExport(cl, list(".var_sampler", ".simple_grammar_sampler",
"variables", "numbers", "create_grammar",
".grammar_sample", "n_iter"),
envir = environment())
output <- pbapply::pblapply(functions,
FUN = .var_sampler,
variables = variables,
numbers = numbers,
n_iter = n_iter,
cl = cl)
parallel::stopCluster(cl)
} else {
RNGkind("L'Ecuyer-CMRG")
set.seed(seed)
parallel::mc.reset.stream()
output <- unlist(pbmcapply::pbmclapply(X = functions,
FUN = .var_sampler,
variables = variables,
numbers = numbers,
n_iter = n_iter,
mc.cores = as.integer(no_cores)))
}
output <- unique(output)
return(output)
}
bla <- variable_input(functions = fun, variables, numbers)
head(bla)
variable_input <- function(functions, variables, numbers, n_iter = 100, no_cores = NULL, seed = NULL){
if(is.data.frame(functions)){
if(ncol(functions) == 1){
functions <- as.character(functions)
} else stop("functions must be either a character vector or a 1 column data frame with function strings.")
} else {
if(!is.character(functions)){
stop("functions must be either a character vector or a 1 column data frame with function strings.")
}
}
# NULL seed
if(is.null(seed)) seed <- sample(1e+9, 1)
# Calculate the number of cores if not specified
if (is.null(no_cores)) {
no_cores <- min(1, parallel::detectCores() - 2)
}
no_cores <- min(parallel::detectCores(), no_cores)
# parallel sampling
cat("Sampling varialbes and/or numerics", n_iter, "times with", no_cores, "cores:\n")
if(Sys.info()[["sysname"]] == "Windows"){
# use parlapply version for windows
cl <- parallel::makeCluster(no_cores)
parallel::clusterSetRNGStream(cl, iseed = seed)
parallel::clusterExport(cl, list(".var_sampler", ".simple_grammar_sampler",
"variables", "numbers", "create_grammar",
".grammar_sample", "n_iter"),
envir = environment())
output <- unlist(pbapply::pblapply(functions,
FUN = .var_sampler,
variables = variables,
numbers = numbers,
n_iter = n_iter,
cl = cl))
parallel::stopCluster(cl)
} else {
RNGkind("L'Ecuyer-CMRG")
set.seed(seed)
parallel::mc.reset.stream()
output <- unlist(pbmcapply::pbmclapply(X = functions,
FUN = .var_sampler,
variables = variables,
numbers = numbers,
n_iter = n_iter,
mc.cores = as.integer(no_cores)))
}
output <- unique(output)
return(output)
}
bla <- variable_input(functions = fun, variables, numbers)
head(bla)
dim(bla)
length(bla)
simple_grammar <- create_grammar(a = "<b><op><c>, <a><op><b>, <a><op><c>, 1",
b = "2, 4",
c = "1, 3, 5",
op = "+, -")
grammar_functions <- grammar_sampler(n = 300,
grammar = simple_grammar,
max_depth = 5)
devtools::load_all("D:/Dropbox/Diss/FSO_mHM/FSO")
devtools::load_all("D:/Dropbox/Diss/FSO_mHM/FSO")
grammar_functions <- grammar_sampler(n = 300,
grammar = simple_grammar,
max_depth = 5)
getwd()
paste0("sampled_grammar", "-",
format(Sys.time(), "%d-%m-%Y-%H:%M"), ".feather")
devtools::load_all("D:/Dropbox/Diss/FSO_mHM/FSO")
grammar_functions <- grammar_sampler(n = 300,
grammar = simple_grammar,
max_depth = 5, save = FALSE)
